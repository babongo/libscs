<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="info" docName="draft-ietf-xml2rfc-template-05" ipr="full3978">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <title abbrev="">SCS: Secure Cookie Sessions for HTTP</title>

    <author fullname="Stefano Barbato" initials="S.B." surname="Barbato">
      <organization>KoanLogic Srl</organization>

      <address>
        <postal>
          <street>via Marmolada, 4</street>

          <city>Vitorchiano (VT)</city>

          <region></region>

          <code>01030</code>

          <country>Italy</country>
        </postal>

        <phone></phone>

        <email>tat@koanlogic.com</email>
      </address>
    </author>

    <author fullname="Steven Dorigotti" initials="S.D." surname="Dorigotti">
      <organization>KoanLogic Srl</organization>

      <address>
        <postal>
          <street>via Maso della Pieve 25/C</street>

          <city>Bolzano</city>

          <region></region>

          <code>39100</code>

          <country>Italy</country>
        </postal>

        <phone></phone>

        <email>stewy@koanlogic.com</email>
      </address>
    </author>

    <author fullname="Thomas Fossati" initials="T.F." role="editor"
            surname="Fossati">
      <organization>KoanLogic Srl</organization>

      <address>
        <postal>
          <street>Via di Sabbiuno 11/5</street>

          <city>Bologna</city>

          <region></region>

          <code>40139</code>

          <country>Italy</country>
        </postal>

        <phone>+39 644 82 68</phone>

        <email>tho@koanlogic.com</email>
      </address>
    </author>

    <date year="2011" />

    <!-- Meta-data Declarations -->

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>HTTP Secure Cookies</keyword>

    <abstract>
      <t>This document provides an overview of SCS, a cryptographic protocol
      aimed at the protection of client-side HTTP sessions, i.e. sessions in
      which the application state is held entirely on the client in the form
      of cookies [DRAFT_BARTH].</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>SCS is a cryptographic protocol aimed at protecting client-side HTTP
      sessions, i.e. sessions in which the application state (for example,
      whether or not authentication credentials have been provided) is held
      entirely by the client in the form of cookies <xref
      target="RFC2629"></xref>.</t>

      <t>SCS allows HTTP servers to handle application-level sessions in a
      completely stateless manner.</t>

      <t>An SCS enabled server delegates the application state storage to the
      client (e.g. a browser) - which basically acts as a remote storage
      device. A set of cryptographic transformations is used to ensure that
      confidentiality and information authenticity attributes of state data
      have the same characteristics as for typical "server-side" sessions.</t>

      <t>Anyway, a peculiar difference between SCS and "server-side" cookie
      sessions arises when we carefully consider the roles of the playing
      entities. In the "server-side" model, the Server acts a triple role as
      the "generator", the "owner", and the "verifier" of cookie credentials.
      Instead, a server implementing SCS acts the "generator" and "verifier"
      roles only -- the "owner" being inapplicable as long as we have imposed
      the no-storage requirement.</t>

      <t>In all respects, the Server grants the custody of the generated
      cookie to the Client, whose trust model needs to be taken into
      consideration when designing applications using SCS. The consequences of
      such discrepancy (e.g. deliberate deletion of a cookie, explicit
      privilege revocation, etc.) will be explored and analyzed in Section
      5.2.</t>

      <t>The no-storage requirement, which is the key design constraint of
      SCS, makes it an ideal candidate in the following settings: 
      <list style="letters">
          <t>devices with little or no storage - typically embedded devices -
          which provide functionality such as software updates, configuration,
          device monitoring, etc. via an HTTP interface;</t>

          <t>web applications with HA or load balancing requirements, which
          may delegate handling of the application state to clients instead of
          using shared storage or forced peering.</t>
      </list></t>

    </section>

    <section title="Requirements Language">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119">RFC 2119</xref>.</t>
    </section>

    <section title="Protocol">
      <t>The SCS protocol defines: <list style="symbols">
          <t>a PDU, as a well-defined aggregate of cookies (Section 3.1);</t>

          <t>the cryptographic transformations which manipulate the PDU field
          (Section 3.2);</t>

          <t>the HTTP-based PDU exchange model (Section 3.3).</t>
        </list></t>

      <t>Note that the PDU is transmitted to the client as an opaque data
      block, hence no interpretation nor validation is necessary.</t>

      <t>The single requirement for client-side support of SCS is cookie
      activation on the browser. Only the server is involved in the PDU
      manipulation process.</t>

      <t>In the following sections we define S to be one or more
      interchangeable HTTP server entities (e.g. a server pool in a
      load-balanced or HA environment) and C to be the client with a
      cookie-enabled browser.</t>

      <section title="PDU Description">
        <t>S and C exchange the same PDU (Section 3.3), which consists of a
        set of interdependent cookies tied together by cryptographic
        transformations.</t>

        <t>Confidentiality is limited to the application state information
        (i.e. SCS_DATA cookie), while integrity and authentication apply to
        the entire PDU.</t>

        <section title="SCS_ATIME">
          <t>Timestamp relating to the last read or write operation performed
          on session data, encoded as the number of seconds since UNIX
          epoch.</t>

          <t>This value is updated with each client contact and is used to
          identify expired sessions.</t>

          <t>If the received SCS_ATIME value is older than a predefined
          "session_max_age" (which is chosen by S as an application-level
          parameter), a session is considered to be no longer valid, and
          therefore rejected.</t>
        </section>

        <!-- end of SCS_ATIME -->

        <section title="SCS_DATA">
          <t>Block of encrypted and compressed data, containing session state.
          Note that no restriction is imposed on plain text structure: the
          protocol is completely agnostic as to state data layout.</t>

          <t>If the total size of the SCS_DATA cookie, including name, value
          and attributes, exceeds 4096 bytes (Section 6.1. of [DRAFT_BARTH]),
          it is sliced into n SCS_DATA{n} cookies, each 4KB in size, so that
          the concatenation of their values ordered by cookie name (1, 2, ...,
          N) yields the original SCS_DATA.</t>

          <t>It is suggested [DRAFT_BARTH] that browsers accept at least 50
          cookies per domain, which could lead to a theoretical limit of 184
          KB as the maximum allowed state data block.</t>

          <t>Anyway, in order to minimize both network bandwidth and client
          cookie store consumption, applications should try to upper bound
          state data to some sensible value.</t>
        </section>

        <!-- end of SCS_DATA -->

        <section title="SCS_TID">
          <t>Unique identifier of the transform set (keys and algorithms) used
          to generate this PDU.</t>

          <t>SCS assumes that a key-agreement/distribution mechanism exists
          for environments in which S consists of multiple servers (it may
          consist of a simple key-refresh in the case |S|=1), which provides a
          unique external identifier for each transform set defined and shared
          amongst pool members.</t>

          <t>This identifier (equivalent to a SPI in a Data Security SA
          [MSEC]) is represented in the cookie value.</t>
        </section>

        <!-- end of SCS_TID -->

        <section title="SCS_IV">
          <t>Initialization Vector used for the encryption algorithm (Section
          3.2).</t>

          <t>In order to avoid providing correlation information to a possible
          attacker with access to a sample of SCS PDUs, the IV MUST be created
          randomly for each PDU.</t>
        </section>

        <!-- end of SCS_IV -->

        <section title="SCS_AUTHTAG">
          <t>Authentication tag based on the concatenation of SCS_ATIME,
          SCS_DATA, SCS_TID and SCS_IV.</t>

          <t>The concatenation operation is done by packing the four strings
          containing the base64 encoded values in order (e.g.:
          "ZGF0YQ==YXRpbWU=dGlkaXY="), and supplying the resulting string to
          HMAC.</t>
        </section>

        <!-- end of SCS_AUTHTAG -->
      </section>

      <!-- end PDU description -->

      <section title="Crypto Transform">
        <t>SCS could potentially use any combination of primitives capable of
        performing authenticated encryption.</t>

        <t>In practice an encrypt-then-mac approach [KOHNO] with CBC-mode
        encryption and HMAC [HMAC] authentication was chosen.</t>

        <t>The two algorithms MUST be associated with two independent
        keys.</t>

        <t>The possibility of using UMAC for authentication [UMAC] has been
        taken into consideration, but priority was given to space over
        performance: the nonce field transfer would require an extra cookie,
        therefore reducing the space reserved to state information by another
        4KB.</t>

        <t>The following conventions will be used in the algorithm description
        (Section 3.2.5 and Section 3.2.4):

          <list style="symbols">
            <t>Enc/Dec(): encryption/decryption functions (Section 3.2.1);</t>

            <t>HMAC(): authentication function (Section 3.2.1);</t>

            <t>Comp/Uncomp(): compression/decompression functions (Section
            3.2.2);</t>

            <t>e/d(): cookie value encoding/decoding functions (Section
            3.2.3);</t>

            <t>RAND(): random number generator [RAND].</t>
          </list></t>

        <section title="Cipher Set">
          <t>Implementors MUST support at least the following algorithms:
            <list style="symbols">
              <t>AES-CBC-128 for encryption;</t>

              <t>HMAC-SHA1 with a 128 bit key for authenticity and
              integrity,</t>
            </list> which appear to be sufficiently secure in a wide range of
          use cases [BELLARE] and are widely available.</t>

          <t>One should consider using larger cryptographic key lengths (192
          or 256 bit) according to the actual security and overall system
          performance requirements.</t>

          <section title="Compression">
            <t>Compression, which may be useful or even necessary when
            handling large quantities of data, is not compulsory (in such case
            Comp/Uncomp are replaced by an identity matrix). If this function
            is enabled, DEFLATE [4] format MUST be supported.</t>

            <t>Compression should not be enabled when handling relatively
            short and entropic state (e.g. pseudo random session identifiers).
            Instead, large and quite regular state blobs could receive a
            significant boost when compressed.</t>
          </section>

          <!-- end Compression -->

          <section title="Cookie Encoding">
            <t>Base-64 [BASE] is used for encoding/decoding of cookie values.
            It is quite efficient in terms of space occupation and is very
            wide-spread.</t>
          </section>

          <!-- end Cookie Encoding -->

          <section title="Outbound Transform">
            <t>The output data transformation as seen by the server (the only
            actor which manipulates PDUs) is illustrated by the following
            pseudo-code:
              <list style="numbers">
                <t>iv = RAND()</t>

                <t>atime = NOW</t>

                <t>data = Enc(Comp(state))</t>

                <t>tag = HMAC(e(data)||e(atime)||e(tid)||e(iv))</t>
              </list></t>

            <t>NOW is defined as the current timestamp of the server
            clock.</t>

            <t>Since the only user of the atime field is the server, it is
            unnecessary for it to be synchronized with the client. However, if
            multiple servers are active in a load-balancing configuration,
            clocks SHOULD be synchronized to avoid errors in the calculation
            of session expiry.</t>

            <t>If the length of (compressed) state is not a multiple of the
            block size, its value will be filled with padding bytes of equal
            value as the pad length -- see Section 6.3 of [CMS].</t>

            <t>Hence the SCS PDU fields are created as follows:
              <list style="empty">
                <t>SCS_ATIME = e(atime)</t>

                <t>SCS_AUTHTAG = e(tag)</t>

                <t>SCS_DATA = e(data)</t>

                <t>SCS_TID = e(tid)</t>

                <t>SCS_IV = e(iv)</t>
              </list></t>
          </section>

          <!-- end Outbound Transform -->

          <section title="Inbound Transform">
            <t>The inbound transformation is described by the following:</t>

            <!-- TODO
    <t>
    <list style="numbers">
    <t>
        If (tid is available)
    </t>
    <t>
        data' = d($SCS_DATA)
        atime' = d($SCS_ATIME)
        tid' = d($SCS_TID)
        iv' = d($SCS_IV)
        tag' = d($SCS_AUTHTAG)
    </t>
    <list>
    </t>
-->
            <t>If the cryptographic credentials (encryption and authentication algorithms identified by SCS_TID) are unavailable (step 7.), the inbound PDU cannot be interpreted correctly.</t>  
            
            <t>This may happen for several reasons: for example, if a device without storage has been reset and loses the credentials stored in RAM, or if a server pool node desynchronizes, etc.</t>

            <t>Note that step 4. allows any altered packets or expired sessions to be discarded, hence avoiding unnecessary state decryption and decompression.</t>

          </section>    
          <!-- end Inbound Transform -->
        </section>
        <!-- end Cipher Set -->
      </section>
      <!-- end Crypto Transform -->

      <section title="PDU Exchange">
        <t>SCS can be modeled in the same manner as a typical store-and-forward protocol, in which the endpoints are S, consisting of one or more HTTP servers and the client C, an intermediate node used to "temporarily" store the data to be successively forwarded to S.</t>
        <t>In brief, S and C exchange an immutable cookie data block (Section 3.1): the state is stored on the client at the first hop and then restored on the server at the second, as in <xref target="fig_pdu_exchange"></xref>.
</t>
        <figure anchor="fig_pdu_exchange">
            <artwork align="left"><![CDATA[
       1.  dump-state:
                  Set-Cookie: SCS_DATA=...;
                  Expires=...; Path=...;
                  Domain=...;
           S -->                           --> C
                  Set-Cookie: SCS_TID=...;
                  Expires=...; Path=...;
                  Domain=...;
                  ...

       2.  restore-state:
                  Cookie: SCS_DATA=...;
           C -->  Cookie: SCS_TID=...;     --> S
                  ...
            ]]></artwork>
        </figure>

        <t>SCS cookies MUST NOT be folded into a single HTTP header field, see Section 3 of [DRAFT_BARTH].</t>

        <t>Note that although SCS cookies always have the same naming, there can be multiple active SCS sessions in use at a given user-agent as long as the tuple (SCS PDU, Domain, Path) is different.</t>

        <section title="Cookie Attributes">
          <t>All SCS cookies belonging to the same PDU MUST carry the same attributes' set.  This is not elegant nor bandwidth-friendly solution, but it is necessary in order to guarantee the PDU coherence.</t>
          <t>In the following sub paragraphs a series of recommendations is provided in order to maximize SCS PDU fitness in the generic cookie ecosystem.</t>

          <section title="Expires">
            <t>SCS cookies MUST include an Expires attribute which shall be set to a value consistent with session_max_age.</t>  
            <t>For maximum compatibility with existing user agents the timestamp value MUST be encoded in rfc1123-date format which requires a 4-digit year.</t>
          </section>
          
          <section title="Max-Age">
            <t>Since not all UAs support this attribute, it MUST NOT be present in any SCS cookie.</t>
          </section>
          
          <section title="Domain">
            <t>SCS cookies MUST include a Domain attribute compatible with application usage.</t>
            <t>A trailing '.' MUST NOT be present in order to minimize the possibility of a user-agent ignoring the attribute value.</t>
          </section>
          
          <section title="Secure">
            <t>This attribute MUST always be asserted when SCS sessions are carried over a TLS channel.</t>
          </section>
        
        </section>
        <!-- end Cookie Attributes -->
      </section>
      <!-- end PDU Exchange -->
    </section>
    <!-- end Protocol -->

    <section title="Key Management and Session State">
      <t>This specification provides some common recommendations and praxis relevant to cryptographic key management.</t>  
      <t>In the following, the term 'key' references both encryption and HMAC keys.
      <list style="symbols">
        <t>The key SHOULD be generated securely following the randomness recommendations in [RAND];</t>
        <t>the key length SHOULD be at least 128 bits;</t>
        <t>the key SHOULD only be used to generate and verify SCS PDUs;</t>
        <t>the key SHOULD be replaced regularly as well as any time the format of SCS PDUs or cryptographic algorithms changes.</t>
      </list></t>
      <t>Furthermore, to preserve the validity of active HTTP sessions upon renewal of cryptographic credentials (whenever the value of SCS_TID changes), an SCS server MUST be capable of managing at least two transforms contemporarily: the currently instantiated one, and its predecessor.</t>
      <t>Each transform set is associated with an attribute pair: "refresh" and "expiry", which is used to identify the exposure limits (in terms of time or quantity of encrypted and/or authenticated bytes, etc) of related cryptographic material.</t>
      <t>In particular, the "refresh" attribute specifies the time limit for substitution of transform set T with new material T'.  From that moment onwards, and for an amount of time determined by "expiry", all new sessions will be created using T', while the active T-protected ones go through a translation phase in which:
        <list style="symbols">
          <t>the inbound transformation authenticates and decrypts/decompresses
      using T (identified by SCS_TID);</t>
          <t>the outbound transformation encrypts/compresses and authenticates
      using T'.</t>
        </list></t>

        <figure anchor="fig_keylifetime">
            <artwork align="left"><![CDATA[
       T' {not valid yet} |---------------------|----------------
                          |  translation stage  |
       T  ----------------|---------------------| {no longer valid}
                        refresh         refresh + expiry
            ]]></artwork>
        </figure>
      <t>Note that the duration of the HTTP session MUST fit within the lifetime of a given transform set (i.e. from creation time until "refresh" + "expiry").</t>
      <t>In practice, this should not be an obstacle because the longevity of the two entities (HTTP session and SCS transform set) should differ by one or two orders of magnitude.</t>
      <t>An SCS server may take this into account by determining the duration of a session adaptively according to the expected deletion time of the active T, or by setting the "expiry" value to at least the maximum lifetime allowed by an HTTP session.</t>
      <t>Since there is only one refresh attribute also in situations with more than one key (e.g. one for encryption and one for authentication) within the same T, the smallest value is chosen.</t>
      
      
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We would like to thank David Wagner, Lorenzo Cavallaro, ... for their valuable feedback on this document.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">

      <section title="Security of the Cryptographic Protocol">
        <t>From a cryptographic architecture perspective, the described mechanism can be easily traced to an Encode-then-EtM scheme described in [KOHNO].</t>
        <t>Given a "provably-secure" encryption scheme and MAC (as for the algorithms recommended in Section 3.2.1), [KOHNO] demonstrates that their composition results in a secure authenticated encryption scheme.</t>
      </section>

      <section title="Impact of the SCS Cookie Model">
        <t>The fact that the server does not own the cookie it produces, gives rise to a series of consequences that must be clearly understood when one envisages the use of SCS as a cookie provider and validator for his/her application.</t>
        <t>In the following paragraphs, a set of different attack scenarios (together with corresponding countermeasures) are identified and analyzed.</t>
        
        <section title="Old cookie replay">
          <t>SCS doesn't address replay of old cookie values.</t>
          <t>In fact, there is nothing that guarantees an SCS application about the client having returned the most recent version of the cookie.</t>
          <t>As with "server-side" sessions, if an attacker gains possession of a given user's cookies - via simple passive interception or another technique - he/she will always be able to restore the state of an intercepted session by representing the captured data to the server.</t>
          <t>The SCS_ATIME value along with the session_max_age configuration parameter allow SCS to mitigate the chances of an attack (by forcing a time window outside of which a given cookie is no longer valid), but cannot exclude it completely.</t>
          <t>A countermeasure against the "passive interception and replay" scenario can be applied at transport/network level using the anti-replay services provided by e.g., SSL/TLS [TLS-EXT] or IPsec [IPSEC].</t>
          <t>Anyway, a generic solution is still out of scope: an SCS application wishing to be replay-resistant must put in place some ad hoc mechanism to prevent clients (both rogue and legitimate) from (a) being able to replay old cookies as valid credentials and/or (b) getting any advantage by replaying them.</t>
          <t>In the following, some typical use cases are illustrated:
            <list style="symbols">
              <t>Session inactivity timeout scenario (implicit invalidation): use the session_max_age parameter if a global setting is viable, else place an explicit TTL in the cookie (e.g. validity_period="start_time, duration") that can be verified by the application each time the Client presents the SCS cookie.</t>
              <t>Session voidance scenario (explicit invalidation): put a randomly chosen string into each SCS cookie (cid="$(random())") and keep a list of valid session cid's against which the SCS cookie presented by the client can be checked.  When a cookie needs to be invalidated, delete the corresponding cid from the list.  The described method has the drawback that, in case a non-permanent storage is used to archive valid cid's, a reboot/restart would invalidate all sessions (It can't be used when |S| &gt; 1).</t>
              <t>One-shot transaction scenario (ephemeral): this is a variation on the previous theme when sessions are consumed within a single request/response.  Put a nonce="$(random())" within the state information and keep a list of not-yet-consumed nonces in RAM. Once the client presents its cookie credential, the embodied nonce is deleted from the list and will be therefore discarded whenever replayed.</t>
            </list></t>
          <t>It may be noteworthy that despite the chances of preventing replay in some well established circumstances by using aforementioned mechanisms, if the attacker is able to use the cookie before the legitimate client gets a chance to, then the impersonation attack will always succeed.</t>  
        </section>

        <section title="Cookie Deletion">
          <t>A direct consequence of the missing owner role in SCS is that a client could intentionally delete its cookie and return nothing.</t>
          <t>The application protocol has to be designed so there is no incentive to do so, for instance:
            <list style="symbols">
              <t>it is safe for the cookie to represent some kind of positive capability - the possession of which increases the client's powers;</t>
              <t>It is not safe to use the cookie to represent negative capabilities - where possession reduces the client's powers-, or for revocation.</t>
            </list>
          </t>
          <t>Note that this behavior is not equivalent to cookie removal in the "server-side" cookie model, because in case of missing cookie backup by other parties (e.g. the application using SCS), the Client could simply make it disappear once and for all.</t>
        </section>

        <section title="Cookie Sharing or Theft">
          <t>SCS doesn't prevent sharing (both voluntary and illegitimate) of cookies between multiple clients.</t>
          <t>In the context of voluntary cookie sharing, using HTTPS is useless: Client certificates are just as shareable as cookies, hence equivalently to the "server-side" cookie model, there seems to be no way to prevent this threat.</t>
          <t>The theft could be mitigated by securing the wire (e.g. via HTTPS, IPsec, VPN, ...), thus reducing the opportunity of cookie stealing to a successful attack on the protocol endpoints.</t>
        </section>
      </section>

      <section title="Advantages of SCS over Server-side Sessions">
        <t>None of the common vulnerabilities of server-side sessions (SID prediction, SID brute forcing, session fixation [KOLSEK]) can be exploited when using SCS, unless the attacker possesses encryption and HMAC keys (both current ones and those relating to the previous set of credentials).</t>
        <t>More generally no slicing nor altering operations can be done over an SCS PDU without controlling the cryptographic keyset and cipherset.</t>
      </section>
    
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->

      &RFC2119;

      <reference anchor="min_ref">
        <!-- the following is the minimum to make xml2rfc happy -->

        <front>
          <title>Minimal Reference</title>

          <author initials="authInitials" surname="authSurName">
            <organization></organization>
          </author>

          <date year="2006" />
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <!-- Here we use entities that we defined at the beginning. -->

      &RFC2629;

      &RFC3552;

      &I-D.narten-iana-considerations-rfc2434bis;

      <!-- A reference written by by an organization not a person. -->

      <reference anchor="DOMINATION"
                 target="http://www.example.com/dominator.html">
        <front>
          <title>Ultimate Plan for Taking Over the World</title>

          <author>
            <organization>Mad Dominators, Inc.</organization>
          </author>

          <date year="1984" />
        </front>
      </reference>
    </references>

    <section anchor="app-additional" title="Additional Stuff">
      <t>This becomes an Appendix.</t>
    </section>

    <!-- Change Log

v00 2006-03-15  EBD   Initial version

v01 2006-04-03  EBD   Moved PI location back to position 1 -
                      v3.1 of XMLmind is better with them at this location.
v02 2007-03-07  AH    removed extraneous nested_list attribute,
                      other minor corrections
v03 2007-03-09  EBD   Added comments on null IANA sections and fixed heading capitalization.
                      Modified comments around figure to reflect non-implementation of
                      figure indent control.  Put in reference using anchor="DOMINATION".
                      Fixed up the date specification comments to reflect current truth.
v04 2007-03-09 AH     Major changes: shortened discussion of PIs,
                      added discussion of rfc include.
v05 2007-03-10 EBD    Added preamble to C program example to tell about ABNF and alternative 
                      images. Removed meta-characters from comments (causes problems).  -->
  </back>
</rfc>
