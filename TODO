
code:
- experiment with "compact" version of SCS cookie (all atoms in one cookie)
- minimal crypto implementation: aes + hmac + sha1 + rand
- lua bindings
[stewy] python bindings
- php bindings
- doxy framework
- testing driver + test cases
- length constraint over produced cookies
- keyset refresh api
- optional auto generation for keying material


- on darwin with compression enabled I get:
==96275== Conditional jump or move depends on uninitialised value(s)
==96275==    at 0x10002AB3B: deflateEnd (in /usr/lib/libz.1.2.3.dylib)
==96275==    by 0x10002B762: deflateSetDictionary (in /usr/lib/libz.1.2.3.dylib)
==96275==    by 0x10002C914: deflate (in /usr/lib/libz.1.2.3.dylib)
==96275==    by 0x100003020: do_compress (in ./test)
==96275==    by 0x1000014E5: optional_compress (in ./test)
==96275==    by 0x1000010F6: scs_encode (in ./test)
==96275==    by 0x100000E5D: main (in ./test)


doc:
- pack the 5 cookies into 1.  provide some external framing mechanism (e.g.
  '|' separated b64 values) which can be indirectly authenticated by supplying
  each atom's length to HMAC (together with the atom). note that length value 
  is implicit with framing and must not be sent out.
  less space for state data but much simpler and less fragile mechanism + 
  protocol and browser friendly + simplified API:
    scs_encode(state, &cookie);
    state = scs_decode(cookie, &state_sz);
  nothing prevents user to split one logical state cookie over a number of 
  physical cookies.
  also allows free choice of cookie naming.
- s/(It can't be used when |S| > 1)/with an hint on using a sync/lazy querying 
  protocol in case |S| > 1 (sullivan@cs.vu.nl)
- sec 4. "the key length SHOULD be at least 128 bits (of entropy)"


